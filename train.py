# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1awqwqZMQRRErzZz_jfitld6NFyTi2n-C
"""

import torch
import numpy as np
import scipy
import pandas as pd
from collections import Counter

train = pd.read_csv("train.csv")

ratings = np.array(train['rating'].values).astype(np.float32)
userIds = np.array(train['userId'].values)
itemIds = np.array(train['movieId'].values)
total = len(ratings)


  
  
cnt_u = Counter(userIds)
cnt_i = Counter(itemIds)

def compress(cnt):
  d = {}
  dt = {}
  z = 0
  for x in cnt:
    d[x] = z
    dt[z] = x
    z += 1
  return d, dt


[compr_u, compr_ut] = compress(cnt_u)
[compr_i, compr_it] = compress(cnt_i)

rated_u = np.array([cnt_u[compr_ut[i]] for i in compr_ut]).reshape(-1,1)
rated_i = np.array([cnt_i[compr_it[i]] for i in compr_it]).reshape(-1,1)

n_users = len(compr_u)
n_items = len(compr_i)

print(n_users, n_items)

userIds = np.array(list(map(lambda x: compr_u[x], userIds)))
itemIds = np.array(list(map(lambda x: compr_i[x], itemIds)))

x_train = torch.stack([torch.from_numpy(userIds),torch.from_numpy(itemIds)],dim = 1)
y_train = torch.from_numpy(ratings)

rateds = set()

for i in range(total):
  rateds.add((x_train[i][0].item(),x_train[i][1].item()))

print((0,0) in rateds)

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

class Net(nn.Module):
    def __init__(self):
      super(Net, self).__init__()
      self.bu = nn.Parameter(torch.rand(n_users, requires_grad=True, dtype=torch.float))
      self.bi = nn.Parameter(torch.rand(n_items, requires_grad=True, dtype=torch.float))
      self.nu = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))

      self.embedding_users = nn.Embedding(n_users,20)
      self.embedding_items = nn.Embedding(n_items,20)
      self.linear1 = nn.Linear(40,20)
      self.softmax = nn.Softmax(dim = 0)
      self.drop_layer = nn.Dropout(0.2)
      self.linear2 = nn.Linear(20,1)

    def forward(self, x):
      tot = 0
      users = x[:,0]
      items = x[:,1]

      bu = self.bu[users]
      bi = self.bi[items]

      users = self.embedding_users(users)
      items = self.embedding_items(items)
  
      x = torch.cat([users,items], dim = 1)

      x = self.linear1(x)
      x = self.drop_layer(x)
      x = self.linear2(x)
      x = torch.flatten(x)

      return x+bu+bi+self.nu

model = Net()
print(model)

lr = 1e-2
n_epochs = 200

loss_fn = nn.MSELoss(reduction='mean')
optimizer = optim.SGD(model.parameters(), lr=lr)

for epoch in range(n_epochs):
    model.train()

    yhat = model(x_train)
    
    loss = loss_fn(y_train, yhat)
    print("loss ", loss)
    loss.backward()    
    optimizer.step()
    optimizer.zero_grad()
    print("epoch ", epoch)
    
model.eval()

x_test = torch.Tensor([[0,i] for i in range(n_items)]).long()
print(x_test)
print(model(x_test))

model.eval()

def recommend(u):
  u = compr_u[u]
  x_test = torch.Tensor([[u,i] for i in range(n_items) if not (u,i) in rateds]).long()
  R_hat = model(x_test)
  sorted, indices = torch.sort(R_hat,descending=True)
  print(sorted[0:5], indices[0:5])

recommend(1)

torch.save(model, 'model2.pth')

